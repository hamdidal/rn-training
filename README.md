ailogogenerator is a demo mobile application built with Expo and React Native to simulate the Hexa AI Logo & Art Generator. It features an input screen where users enter prompts, a status chip that remains in a “processing” state for a random 30–60 seconds before switching to “done,” and an output screen displaying a mock-generated image. The code is organized to support easy learning and future integration with a real AI backend.

To get started, clone the repository from GitHub and run npm install or yarn install. Next, set up a Firebase project: copy your configuration files into the appropriate platform folders and update the firebaseConfig.ts file with your credentials. Finally, launch the app locally with npm run start (or npm run android, npm run ios, or npm run web) and test the logo generation simulation by entering text, tapping Generate, and waiting for the status chip to change to “done.”

The project follows a clear folder structure. Assets such as fonts and images reside in assets/. The src/ directory contains components/ for reusable UI elements, navigation/ for React Navigation stacks, screens/ for the input and output screens, services/ for Firebase and mock API functions, styles/ for shared design constants, and utils/ for helper functions like timers and random delay generation. The application entry point is App.tsx, and configuration files include package.json and tsconfig.json.

Development scripts include start, which launches the Metro bundler, as well as platform-specific commands (android, ios, web) that invoke Expo start with the appropriate target. The codebase uses Expo SDK 53, React Native 0.79, TypeScript for strict typing, React Navigation v7 for screen management, Firebase for data storage and functions, and useful libraries such as expo-linear-gradient, expo-clipboard, react-native-progress, react-native-svg, and the Manrope font via @expo-google-fonts.

Best practices demonstrated in this project include modular code organization, strong TypeScript typing, a simulated asynchronous flow that can be replaced by real Cloud Functions, React hooks for state management, a clean Git history with frequent, descriptive commits, and comprehensive inline documentation. Training notes highlight how the frontend simulation uses a randomized setTimeout, how to swap the mock service for an actual backend function, and how consistent UI/UX elements (status chip color changes, touch feedback, and typography) contribute to a polished demo. This component-driven design also makes it easy to extend the app with additional screens such as history or settings.
